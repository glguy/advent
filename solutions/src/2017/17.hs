{-# Language QuasiQuotes, ImportQualifiedPost, NumDecimals #-}
{-|
Module      : Main
Description : Day 17 solution
Copyright   : (c) Eric Mertens, 2017
License     : ISC
Maintainer  : emertens@gmail.com

<https://adventofcode.com/2017/day/17>

Day 17 has us repeatedly insert elements into a circular buffer and
asks about the elements following some needle.

Part 1 is small enough that we can generate the whole list quickly
and search it.

Part 2 is large enough that generating the whole list and searching
it uses roughly 5.2 GB of RAM and takes 1 minute 15 seconds on my
hardware to run! We instead optimize things by noticing that the @0@
element is always at the head of the sequence, so we simply need to
find the last element that was written at index @1@.

-}
module Main where

import Advent (format)
import Data.List (elemIndices, foldl', scanl')
import Data.Sequence (Seq)
import Data.Sequence qualified as Seq

-- | Print the solutions to the puzzle. Input file can be overridden
-- via command-line arguments.
main :: IO ()
main =
  do input <- [format|17 %u%n|]
     print (elemAfter 2017 (makeSequence input 2017))
     print (part2 input)

-- | Compute the element that immediately follows the needle
-- in the haystack. This assumes a circular interpretation for
-- the list, so the first element is considered to follow the last.
elemAfter ::
  Int     {- ^ needle            -} ->
  Seq Int {- ^ haystack          -} ->
  Int     {- ^ following element -}
elemAfter x xs = Seq.index xs ( (i+1) `rem` Seq.length xs )
  where
    Just i = Seq.elemIndexL x xs

-- | Compute the buffer generated by inserting elements up to a given
-- element using a particular jump size.
--
-- >>> makeSequence 3 9
-- fromList [0,9,5,7,2,4,3,8,6,1]
makeSequence ::
  Int {- ^ jump size    -} ->
  Int {- ^ last element -} ->
  Seq Int
makeSequence jump sz
  = foldl' (\xs (x,i) -> Seq.insertAt i x xs) Seq.empty
  $ zip [0..sz]
  $ cursors jump

-- | The infinite list of cursors generated from a particular jump parameter.
--
-- >>> take 10 (cursors 3)
-- [0,1,1,2,2,1,5,2,6,1]
cursors ::
  Int   {- ^ jump size        -} ->
  [Int] {- ^ cursor positions -}
cursors jump = scanl' nextCursor 0 [1..]
  where
    nextCursor cursor size = (cursor+jump)`rem`size + 1
{-# Inline cursors #-} -- helps list fusion!

-- | Special case for when we only need to know what number is going
-- to follow the zero. Because the 0 is always going to be at the zero
-- index, whatever the last element to be written to the 1 index must
-- be the element that directly follows the zero.
part2 ::
  Int {- ^ jump size             -} ->
  Int {- ^ number following zero -}
part2 = last . elemIndices 1 . take 5e7 . cursors
