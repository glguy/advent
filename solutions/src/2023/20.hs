{-# Language QuasiQuotes, TemplateHaskell, BangPatterns, LambdaCase, ImportQualifiedPost #-}
{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}
{-|
Module      : Main
Description : Day 20 solution
Copyright   : (c) Eric Mertens, 2023
License     : ISC
Maintainer  : emertens@gmail.com

<https://adventofcode.com/2023/day/20>

This problem requires you to hack around inside your input file,
so if this solution doesn't work on yours, you didn't get lucky
and get a easier case like I did, but I assume we all got the same
kind of dumb easy case as the last LCM problem this year.

-}
module Main (main) where

import Advent (format, stageTH)
import Advent.Queue as Queue
import Data.Map (Map)
import Data.Map qualified as Map
import Data.Set (Set)
import Data.Set qualified as Set

-- | Kind sigil
data K = K | K_PERCENT | K_AMPERSAND
  deriving (Eq, Ord, Show)

data Node
  = Broadcast                      [String] -- ^ broadcast node
  | FlipFlop !Bool                 [String] -- ^ flip-flop
  | Conjunction !Int !(Set String) [String] -- ^ conjunction gate
  deriving (Show)

data Stream a = a :| Stream a

stageTH

-- | Parse the input and print both parts.
--
-- >>> :main
-- 825167435
-- 225514321828633
main :: IO ()
main =
 do input <- [format|2023 20 (@K%a+ -> %a+&(, )%n)*|]
    let incoming = Map.fromListWith (++) [(k, [v]) | (_, v, ks) <- input, k <- ks]
    let nodes = Map.fromList [(name, node incoming name kind conns) | (kind, name, conns) <- input]

    print (part1 (sim nodes))
    print (part2 incoming (sim nodes))

node :: Map String [String] -> String -> K -> [String] -> Node
node incoming name = \case
  K           -> Broadcast
  K_AMPERSAND -> Conjunction (length (Map.findWithDefault [] name incoming)) Set.empty
  K_PERCENT   -> FlipFlop False

part1 :: Stream (String, a, Bool) -> Int
part1 = go 0 0 0
  where
    go n l h ((src,_,sig) :| xs)
      | n == 1000, src == "button" = l * h
      | otherwise =
        go (if src == "button" then n+1 else n)
              (if sig then l else l+1)
              (if sig then h+1 else h) xs

part2 :: Map String [String] -> Stream (String, String, Bool) -> Int
part2 incoming = foldl lcm 1 . go 0 (Set.fromList (Map.findWithDefault [] conj incoming))
  where
    [conj] = incoming Map.! "rx"

    -- finds the first button count for each gate in gates
    go n gates ((src, dst, msg) :| xs)
      | Set.null gates = []
      | "button" == src = go (n + 1) gates xs
      | msg, dst == conj, Set.member src gates = n : go n (Set.delete src gates) xs
      | otherwise = go n gates xs

-- | Generate a stream of messages generated by this network.
-- The button is automatically pressed any time the network
-- stalls.
sim :: Map String Node -> Stream (String, String, Bool)
sim = go Queue.Empty
  where
    go ((src, dst, msg) Queue.:<| q) = dispatch src dst msg q
    go q                             = dispatch "button" "broadcaster" False q

    -- Dispatch msg from src to dst
    dispatch src dst msg q st =
      (src, dst, msg) :|
      case Map.lookup dst st of

        -- broadcast: just forward message to nexts
        Just (Broadcast next) -> send msg next st

        -- flipflop: on low, toggle state and send to nexts
        Just (FlipFlop mode next)
          | not msg -> send out next st' -- was on sends low
          where
            st' = Map.insert dst (FlipFlop out next) st
            out = not mode

        -- conjunction: remember incoming value, transmit nand
        Just (Conjunction sz inc next) -> send out next st'
          where
            inc' = (if msg then Set.insert else Set.delete) src inc
            st'  = Map.insert dst (Conjunction sz inc' next) st
            out  = sz /= length inc'

        -- output node or flipflop on high: ignored
        _ -> go q st
      where
        send msg' next = go (Queue.appendList q [(dst, t, msg') | t <- next])
