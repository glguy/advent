{-# Language QuasiQuotes, TemplateHaskell, BlockArguments, BangPatterns, LambdaCase, ImportQualifiedPost #-}
{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}
{-|
Module      : Main
Description : Day 20 solution
Copyright   : (c) Eric Mertens, 2023
License     : ISC
Maintainer  : emertens@gmail.com

<https://adventofcode.com/2023/day/20>

This problem requires you to hack around inside your input file,
so if this solution doesn't work on yours, you didn't get lucky
and get a easier case like I did, but I assume we all got the same
kind of dumb easy case as the last LCM problem this year.

-}
module Main (main) where

import Advent (format, stageTH)
import Advent.Queue as Queue
import Data.Map (Map)
import Data.Map qualified as Map
import Data.Set (Set)
import Data.Set qualified as Set

-- | Kind sigil
data K = K | K_PERCENT | K_AMPERSAND
  deriving (Eq, Ord, Show)

data Node
  = Broadcast                      [String] -- ^ broadcast node
  | FlipFlop !Bool                 [String] -- ^ flip-flop
  | Conjunction !Int !(Set String) [String] -- ^ conjunction gate
  deriving (Show)

data Outcome = Send String String Bool Outcome | Stall (Map String Node)
  deriving Show

stageTH

[format|(@K%a+ -> %a+&(, )%n)*|]

-- | Parse the input and print both parts.
--
-- >>> :main
-- 825167435
-- 225514321828633
main :: IO ()
main =
 do input <- getInput 2023 20
    let incoming = Map.fromListWith (++) [(k, [v]) | (_, v, ks) <- input, k <- ks]
    let nodes = Map.fromList [(name, node incoming name kind conns) | (kind, name, conns) <- input]

    print (part1 nodes)
    print (part2 incoming nodes)

node :: Map String [String] -> String -> K -> [String] -> Node
node incoming name = \case
  K           -> Broadcast
  K_AMPERSAND -> Conjunction (length (Map.findWithDefault [] name incoming)) Set.empty
  K_PERCENT   -> FlipFlop False

part1 :: Map String Node -> Int
part1 = go (1 :: Int) 0 0 . sim
  where
    go 1000 l h (Stall _        ) = l * h
    go n    l h (Stall net      ) = go (n + 1) l h (sim net)
    go n    l h (Send _ _ sig xs) =
      go n (if sig then l else l+1) (if sig then h+1 else h) xs

part2 :: Map String [String] -> Map String Node -> Int
part2 incoming = foldl lcm 1 . go 1 gates0 . sim
  where
    [conj] = incoming Map.! "rx"
    
    -- all the gates feeding into @conj@
    gates0 = Set.fromList (Map.findWithDefault [] conj incoming)

    -- finds the first button count for each gate in gates
    go _ gates _ | Set.null gates = []
    go n gates (Stall net) = go (n + 1) gates (sim net)
    go n gates (Send src dst msg xs)
      | msg, dst == conj, Set.member src gates = n : go n (Set.delete src gates) xs
      | otherwise = go n gates xs

-- | Generate a stream of messages generated by this network initiated by
-- pressing the button and running until there are no more messages
sim :: Map String Node -> Outcome
sim = dispatch "button" "broadcaster" False Queue.Empty
  where
    go ((src, dst, msg) Queue.:<| q) = dispatch src dst msg q
    go Queue.Empty                   = Stall

    -- Dispatch msg from src to dst
    dispatch src dst msg q st =
      Send src dst msg
      case Map.lookup dst st of

        -- broadcast: just forward message to nexts
        Just (Broadcast next) -> send msg next st

        -- flipflop: on low, toggle state and send to nexts
        Just (FlipFlop mode next)
          | not msg -> send out next st' -- was on sends low
          where
            st' = Map.insert dst (FlipFlop out next) st
            out = not mode

        -- conjunction: remember incoming value, transmit nand
        Just (Conjunction sz inc next) -> send out next st'
          where
            inc' = (if msg then Set.insert else Set.delete) src inc
            st'  = Map.insert dst (Conjunction sz inc' next) st
            out  = sz /= length inc'

        -- output node or flipflop on high: ignored
        _ -> go q st
      where
        send msg' next = go (Queue.appendList q [(dst, t, msg') | t <- next])
